{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#about-polars-pairing","title":"About <code>polars-pairing</code>","text":"<p><code>polars-pairing</code> is a plugin provides pairing functions to Polars. These functions encode a pair of natural numbers into a single natural number.</p> A pairing function performs a one-to-one mapping between <code>(x, y)</code> and <code>i</code> (represented by the circles in the Cartesian coordinate system). Figure by David Hagen. <p>This plugin implements three pairing functions (Hagen<sup>1</sup>, Szudzik<sup>2</sup>, and Cantor<sup>3</sup>), along with their corresponding unpairing functions, as Polars expressions. The pairing functions take two integer columns as input and produce a single column containing the encoded pair. Conversely, the unpairing functions accept a single column as input and generate a struct column containing the values of the original pair.</p>"},{"location":"#installation","title":"Installation","text":"<p><code>polars-pairing</code> can be installed via Python's <code>pip</code>:</p> <pre><code>pip install polars-pairing\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import polars_pairing as plp\n\n&gt;&gt;&gt; df = pl.DataFrame({\n...     \"a\": [1, 2, 38, 4],\n...     \"b\": [5, 6, 77, 80]\n... })\n&gt;&gt;&gt; df.select(plp.col(\"a\").pairing.pair(plp.col(\"b\")).alias(\"pair\"))\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 pair \u2502\n\u2502 ---  \u2502\n\u2502 u64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 28   \u2502\n\u2502 40   \u2502\n\u2502 6006 \u2502\n\u2502 6408 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; df.select(\n...     plp.col(\"a\")\n...     .pairing.pair(plp.col(\"b\"), method=\"hagen\") # (1)!\n...     .alias(\"hagen_pair\"),\n...     plp.col(\"a\")\n...     .pairing.pair(plp.col(\"b\"), method=\"szudzik\")\n...     .alias(\"szudzik_pair\"),\n...     plp.col(\"a\")\n...     .pairing.pair(plp.col(\"b\"), method=\"cantor\")\n...     .alias(\"cantor_pair\"),\n... )\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 hagen_pair \u2506 szudzik_pair \u2506 cantor_pair \u2502\n\u2502 ---        \u2506 ---          \u2506 ---         \u2502\n\u2502 u64        \u2506 u64          \u2506 u64         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 28         \u2506 26           \u2506 26          \u2502\n\u2502 40         \u2506 38           \u2506 42          \u2502\n\u2502 6006       \u2506 5967         \u2506 6747        \u2502\n\u2502 6408       \u2506 6404         \u2506 3650        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; df = pl.DataFrame({\"p\": [28, 40, 6006, 6408]})\n&gt;&gt;&gt; df.select(plp.col(\"p\").pairing.unpair().alias(\"unpair\")) # (2)!\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 unpair    \u2502\n\u2502 ---       \u2502\n\u2502 struct[2] \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 {1,5}     \u2502\n\u2502 {2,6}     \u2502\n\u2502 {38,77}   \u2502\n\u2502 {4,80}    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n&gt;&gt;&gt; df = pl.DataFrame({\"p\": [26, 38, 5967, 6404]})\n&gt;&gt;&gt; df.select(\n...     plp.col(\"p\").pairing.unpair(method=\"szudzik\").alias(\"unpair\")\n... ).unnest(\"unpair\")\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Left \u2506 Right \u2502\n\u2502 ---  \u2506 ---   \u2502\n\u2502 u64  \u2506 u64   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 5     \u2502\n\u2502 2    \u2506 6     \u2502\n\u2502 38   \u2506 77    \u2502\n\u2502 4    \u2506 80    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ol> <li>By default, the Hagen pairing function is used, but you can specify alternative functions. The available methods are: <code>hagen</code>, <code>szudzik</code>, and <code>cantor</code>.</li> <li>The unpairing functions return a struct column containing the values of the original pair.</li> </ol> <ol> <li> <p>Hagen, D. R. Superior Pairing Function. https://drhagen.com/blog/superior-pairing-function/ (2018).\u00a0\u21a9</p> </li> <li> <p>Szudzik, Matthew. \"An elegant pairing function.\" Wolfram Research (ed.) Special NKS 2006 Wolfram Science Conference. 2006.\u00a0\u21a9</p> </li> <li> <p>Cantor, G. Ein Beitrag zur Mannigfaltigkeitslehre. Journal f\u00fcr die reine und angewandte Mathematik 1878, 242\u2013258 (1878).\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#polars_pairing.PairingFunctions","title":"<code>polars_pairing.PairingFunctions</code>","text":"Source code in <code>polars_pairing/__init__.py</code> <pre><code>@pl.api.register_expr_namespace(\"pairing\")\nclass PairingFunctions:\n    def __init__(self, expr: pl.Expr):\n        self._expr = expr\n\n    def pair(\n        self, other: IntoExpr, method: Literal[\"hagen\", \"szudzik\", \"cantor\"] = \"hagen\"\n    ) -&gt; pl.Expr:\n        \"\"\"\n        Applies a pairing function to uniquely encode two nonnegative integers\n        into a single nonnegative integer.\n\n        Parameters\n        ----------\n        method\n            The method to use for pairing. Either \"hagen\", \"szudzik\" or \"cantor\",\n            defaults to \"hagen\".\n\n        Examples\n        --------\n        &gt;&gt;&gt; df = pl.DataFrame(\n        ...     {\n        ...         \"n1\": [2, 2, 3, 1501],\n        ...         \"n2\": [-6, 7, 8, 10740],\n        ...     }\n        ... )\n        &gt;&gt;&gt; df.select(pl.col(\"n1\").pairing.pair(pl.col(\"n2\")).alias(\"pair\"))\n        shape: (4, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 pair      \u2502\n        \u2502 ---       \u2502\n        \u2502 u64       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 null      \u2502\n        \u2502 54        \u2502\n        \u2502 70        \u2502\n        \u2502 115350602 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; df.select(pl.col(\"n1\").pairing.pair(pl.col(\"n2\"), method=\"szudzik\").alias(\"pair\"))\n        shape: (4, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 pair      \u2502\n        \u2502 ---       \u2502\n        \u2502 u64       \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 null      \u2502\n        \u2502 51        \u2502\n        \u2502 67        \u2502\n        \u2502 115349101 \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n        return register_plugin(\n            args=[self._expr, other],\n            kwargs={\"method\": method},\n            symbol=\"pair\",\n            is_elementwise=True,\n            lib=lib,\n        )\n\n    def unpair(\n        self, method: Literal[\"hagen\", \"szudzik\", \"cantor\"] = \"hagen\"\n    ) -&gt; pl.Expr:\n        \"\"\"\n        Applies an unpairing function to uniquely decode a nonnegative integer\n        into two nonnegative integers.\n\n        Parameters\n        ----------\n        method\n            The method to use for unpairing. Either \"hagen\", \"szudzik\" or \"cantor\",\n            defaults to \"hagen\".\n\n        Examples\n        --------\n        &gt;&gt;&gt; df = pl.DataFrame({\"pair\": [None, 607, -4, 18871362]})\n        &gt;&gt;&gt; df.select(pl.col(\"pair\").pairing.unpair().alias(\"unpair\"))\n        shape: (4, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 unpair      \u2502\n        \u2502 ---         \u2502\n        \u2502 struct[2]   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 {null,null} \u2502\n        \u2502 {24,15}     \u2502\n        \u2502 {null,null} \u2502\n        \u2502 {513,4344}  \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        &gt;&gt;&gt; df.select(pl.col(\"pair\").pairing.unpair(method=\"szudzik\").alias(\"unpair\"))\n        shape: (4, 1)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 unpair      \u2502\n        \u2502 ---         \u2502\n        \u2502 struct[2]   \u2502\n        \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n        \u2502 {null,null} \u2502\n        \u2502 {24,7}      \u2502\n        \u2502 {null,null} \u2502\n        \u2502 {1026,4344} \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \"\"\"\n        return register_plugin(\n            args=[self._expr],\n            kwargs={\"method\": method},\n            symbol=\"unpair\",\n            is_elementwise=True,\n            lib=lib,\n        )\n</code></pre>"},{"location":"reference/#polars_pairing.PairingFunctions.pair","title":"<code>pair(other, method='hagen')</code>","text":"<p>Applies a pairing function to uniquely encode two nonnegative integers into a single nonnegative integer.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['hagen', 'szudzik', 'cantor']</code> <p>The method to use for pairing. Either \"hagen\", \"szudzik\" or \"cantor\", defaults to \"hagen\".</p> <code>'hagen'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame(\n...     {\n...         \"n1\": [2, 2, 3, 1501],\n...         \"n2\": [-6, 7, 8, 10740],\n...     }\n... )\n&gt;&gt;&gt; df.select(pl.col(\"n1\").pairing.pair(pl.col(\"n2\")).alias(\"pair\"))\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 pair      \u2502\n\u2502 ---       \u2502\n\u2502 u64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null      \u2502\n\u2502 54        \u2502\n\u2502 70        \u2502\n\u2502 115350602 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; df.select(pl.col(\"n1\").pairing.pair(pl.col(\"n2\"), method=\"szudzik\").alias(\"pair\"))\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 pair      \u2502\n\u2502 ---       \u2502\n\u2502 u64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null      \u2502\n\u2502 51        \u2502\n\u2502 67        \u2502\n\u2502 115349101 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>polars_pairing/__init__.py</code> <pre><code>def pair(\n    self, other: IntoExpr, method: Literal[\"hagen\", \"szudzik\", \"cantor\"] = \"hagen\"\n) -&gt; pl.Expr:\n    \"\"\"\n    Applies a pairing function to uniquely encode two nonnegative integers\n    into a single nonnegative integer.\n\n    Parameters\n    ----------\n    method\n        The method to use for pairing. Either \"hagen\", \"szudzik\" or \"cantor\",\n        defaults to \"hagen\".\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pl.DataFrame(\n    ...     {\n    ...         \"n1\": [2, 2, 3, 1501],\n    ...         \"n2\": [-6, 7, 8, 10740],\n    ...     }\n    ... )\n    &gt;&gt;&gt; df.select(pl.col(\"n1\").pairing.pair(pl.col(\"n2\")).alias(\"pair\"))\n    shape: (4, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 pair      \u2502\n    \u2502 ---       \u2502\n    \u2502 u64       \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 null      \u2502\n    \u2502 54        \u2502\n    \u2502 70        \u2502\n    \u2502 115350602 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    &gt;&gt;&gt; df.select(pl.col(\"n1\").pairing.pair(pl.col(\"n2\"), method=\"szudzik\").alias(\"pair\"))\n    shape: (4, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 pair      \u2502\n    \u2502 ---       \u2502\n    \u2502 u64       \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 null      \u2502\n    \u2502 51        \u2502\n    \u2502 67        \u2502\n    \u2502 115349101 \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return register_plugin(\n        args=[self._expr, other],\n        kwargs={\"method\": method},\n        symbol=\"pair\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/#polars_pairing.PairingFunctions.unpair","title":"<code>unpair(method='hagen')</code>","text":"<p>Applies an unpairing function to uniquely decode a nonnegative integer into two nonnegative integers.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['hagen', 'szudzik', 'cantor']</code> <p>The method to use for unpairing. Either \"hagen\", \"szudzik\" or \"cantor\", defaults to \"hagen\".</p> <code>'hagen'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = pl.DataFrame({\"pair\": [None, 607, -4, 18871362]})\n&gt;&gt;&gt; df.select(pl.col(\"pair\").pairing.unpair().alias(\"unpair\"))\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 unpair      \u2502\n\u2502 ---         \u2502\n\u2502 struct[2]   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 {null,null} \u2502\n\u2502 {24,15}     \u2502\n\u2502 {null,null} \u2502\n\u2502 {513,4344}  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; df.select(pl.col(\"pair\").pairing.unpair(method=\"szudzik\").alias(\"unpair\"))\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 unpair      \u2502\n\u2502 ---         \u2502\n\u2502 struct[2]   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 {null,null} \u2502\n\u2502 {24,7}      \u2502\n\u2502 {null,null} \u2502\n\u2502 {1026,4344} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>polars_pairing/__init__.py</code> <pre><code>def unpair(\n    self, method: Literal[\"hagen\", \"szudzik\", \"cantor\"] = \"hagen\"\n) -&gt; pl.Expr:\n    \"\"\"\n    Applies an unpairing function to uniquely decode a nonnegative integer\n    into two nonnegative integers.\n\n    Parameters\n    ----------\n    method\n        The method to use for unpairing. Either \"hagen\", \"szudzik\" or \"cantor\",\n        defaults to \"hagen\".\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = pl.DataFrame({\"pair\": [None, 607, -4, 18871362]})\n    &gt;&gt;&gt; df.select(pl.col(\"pair\").pairing.unpair().alias(\"unpair\"))\n    shape: (4, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 unpair      \u2502\n    \u2502 ---         \u2502\n    \u2502 struct[2]   \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 {null,null} \u2502\n    \u2502 {24,15}     \u2502\n    \u2502 {null,null} \u2502\n    \u2502 {513,4344}  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    &gt;&gt;&gt; df.select(pl.col(\"pair\").pairing.unpair(method=\"szudzik\").alias(\"unpair\"))\n    shape: (4, 1)\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 unpair      \u2502\n    \u2502 ---         \u2502\n    \u2502 struct[2]   \u2502\n    \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    \u2502 {null,null} \u2502\n    \u2502 {24,7}      \u2502\n    \u2502 {null,null} \u2502\n    \u2502 {1026,4344} \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \"\"\"\n    return register_plugin(\n        args=[self._expr],\n        kwargs={\"method\": method},\n        symbol=\"unpair\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"}]}